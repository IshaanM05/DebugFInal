/**
 * @file process_lidar.cpp
 * @brief Optimized Process Lidar Node
 */

#include "perception_winter/process_lidar.hpp"
#include <string>
#include <algorithm>
#include <cmath>
#include <optional>
#include <open3d/Open3D.h>
#include <Eigen/Dense>
#include <pcl/point_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/passthrough.h>
#include <pcl/ModelCoefficients.h>
#include <chrono>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <omp.h>

ProcessLidar::ProcessLidar() : Node("process_lidar")
{
    RCLCPP_INFO(this->get_logger(), "Process Lidar Node started");

    cloud_queue_ = std::queue<sensor_msgs::msg::PointCloud::SharedPtr>();

    lidar_raw_input_sub = this->create_subscription<sensor_msgs::msg::PointCloud>(
        lidar_raw_input_topic,
        rclcpp::SensorDataQoS(),
        std::bind(&ProcessLidar::lidar_raw_sub_callback, this, std::placeholders::_1)
    );

    classified_cones_output_rviz_pub = this->create_publisher<visualization_msgs::msg::MarkerArray>(
        classified_cones_output_rviz_topic,
        10
    );

    this->min_z_normal_component = 0.80;
    this->max_slope_deviation_deg = 10.0;

    worker_thread_ = std::thread([this]() { this->processingWorker(); });
    RCLCPP_INFO(this->get_logger(), "[DEBUG] Constructor finished.");
}

ProcessLidar::~ProcessLidar()
{
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        stop_worker_ = true;
        queue_cv_.notify_all();
    }
    if (worker_thread_.joinable())
        worker_thread_.join();
    RCLCPP_INFO(this->get_logger(), "[DEBUG] Destructor called. Shutting down.");
}

void ProcessLidar::lidar_raw_sub_callback(const sensor_msgs::msg::PointCloud::SharedPtr msg)
{
    std::lock_guard<std::mutex> lock(queue_mutex_);
    cloud_queue_.push(msg);
    queue_cv_.notify_one();
}

void ProcessLidar::processingWorker()
{
    while (rclcpp::ok())
    {
        sensor_msgs::msg::PointCloud::SharedPtr msg;
        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            queue_cv_.wait(lock, [this]() { return !cloud_queue_.empty() || stop_worker_; });
            if (stop_worker_) break;
            msg = cloud_queue_.front();
            cloud_queue_.pop();
        }
        if (msg) this->processCloud(msg);
    }
}

void ProcessLidar::processCloud(const sensor_msgs::msg::PointCloud::SharedPtr msg)
{
    auto pipeline_start = std::chrono::steady_clock::now();
    if (msg->points.empty()) return;
    if (msg->channels.empty() || msg->channels[0].values.size() != msg->points.size()) return;

    std::vector<std::vector<double>> positions, colors;
    std::vector<double> intensities;

    // Preallocate cloud and directly assign slices to threads
    auto cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    cloud->points.resize(msg->points.size());

    #pragma omp parallel for
    for (size_t i = 0; i < msg->points.size(); ++i) {
        const auto& pt = msg->points[i];
        pcl::PointXYZI p; p.x = pt.x; p.y = pt.y; p.z = pt.z;
        p.intensity = (msg->channels.empty()) ? 0.0 : msg->channels[0].values[i];
        cloud->points[i] = p;
    }

    // Pass-through filters (ROI)
    auto cloud_filtered = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    pcl::PassThrough<pcl::PointXYZI> pass;
    pass.setInputCloud(cloud); pass.setFilterFieldName("y"); pass.setFilterLimits(-3,3); pass.filter(*cloud_filtered);
    pass.setInputCloud(cloud_filtered); pass.setFilterFieldName("z"); pass.setFilterLimits(-1.0,2.0); pass.filter(*cloud_filtered);

    // Ground plane extraction using RANSAC
    auto non_ground_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    auto ground_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    auto remaining_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>(*cloud_filtered);

    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::SACSegmentation<pcl::PointXYZI> seg;
    pcl::ExtractIndices<pcl::PointXYZI> extract;

    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setDistanceThreshold(this->ransac_threshold);

    int iterations = 0; const int max_iterations = 5;
    const size_t min_points_for_plane = 350;
    std::optional<Eigen::Vector3f> reference_normal;

    while (remaining_cloud->points.size() > min_points_for_plane && iterations < max_iterations)
    {
        seg.setInputCloud(remaining_cloud); seg.segment(*inliers, *coefficients);
        if (inliers->indices.empty()) break;

        Eigen::Vector3f normal(coefficients->values[0], coefficients->values[1], coefficients->values[2]);
        if (normal.z() < 0) normal = -normal;
        if (normal.z() < min_z_normal_component) break;

        if (!reference_normal.has_value()) reference_normal = normal;
        else {
            double dot = normal.dot(reference_normal.value());
            if (std::acos(std::clamp(dot, -1.0, 1.0)) * 180.0 / M_PI > max_slope_deviation_deg) break;
        }

        auto current_ground_plane = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
        extract.setInputCloud(remaining_cloud); extract.setIndices(inliers); extract.setNegative(false); extract.filter(*current_ground_plane);
        *ground_cloud += *current_ground_plane;

        extract.setNegative(true); auto next_remaining_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
        extract.filter(*next_remaining_cloud); remaining_cloud = next_remaining_cloud;
        iterations++;
    }

    *non_ground_cloud = *remaining_cloud;

    // Prepare positions & intensities for clustering
    positions.resize(non_ground_cloud->points.size());
    intensities.resize(non_ground_cloud->points.size());
    #pragma omp parallel for
    for (size_t i = 0; i < non_ground_cloud->points.size(); ++i) {
        auto& pt = non_ground_cloud->points[i];
        positions[i] = {pt.x, pt.y, pt.z};
        intensities[i] = pt.intensity;
    }

    // Open3D DBSCAN clustering
    auto o3d_pcd = std::make_shared<open3d::geometry::PointCloud>();
    o3d_pcd->points_.resize(positions.size());
    #pragma omp parallel for
    for (size_t i = 0; i < positions.size(); ++i)
        o3d_pcd->points_[i] = Eigen::Vector3d(positions[i][0], positions[i][1], positions[i][2]);

    std::vector<int> labels = o3d_pcd->ClusterDBSCAN(dbscan_epsilon, dbscan_minpoints);
    int num_labels = *std::max_element(labels.begin(), labels.end()) + 1;

    std::vector<std::vector<std::vector<double>>> classified_points(num_labels);
    for (size_t i = 0; i < positions.size(); ++i) {
        int label = labels[i]; if (label == -1) continue;
        classified_points[label].push_back({positions[i][0], positions[i][1], positions[i][2], intensities[i]});
    }

    // Sort each cluster by height (z)
    for (auto& cls : classified_points)
        std::sort(cls.begin(), cls.end(), [](auto& a, auto& b){ return a[2] > b[2]; });

    colors.clear(); positions.clear();
    std::vector<std::vector<double>> tmp_positions(num_labels), tmp_colors(num_labels);

    #pragma omp parallel for
    for (int c_idx = 0; c_idx < num_labels; ++c_idx) {
        auto& cls = classified_points[c_idx];
        if (cls.size() < 10) continue;

        std::vector<double> intensity_vals, z_vals;
        for (auto& pt : cls) { intensity_vals.push_back(pt[3]); z_vals.push_back(pt[2]); }

        const double CONE_BASE_RADIUS = 0.12;
        auto min_x_it = std::min_element(cls.begin(), cls.end(), [](auto& a, auto& b){ return a[0] < b[0]; });

        double cone_x = (*min_x_it)[0] + CONE_BASE_RADIUS + 2.921;
        double cone_y = (*min_x_it)[1]; double cone_z = 0.1629;

        int kernel = std::max(3, static_cast<int>(0.1 * intensity_vals.size()));
        if (kernel % 2 == 0) kernel += 1;

        auto avg_intensity = movingAverage(intensity_vals, kernel);
        tmp_positions[c_idx] = {cone_x, cone_y, cone_z};
        tmp_colors[c_idx] = classifyCone(avg_intensity, z_vals) ? std::vector<double>{1.0,1.0,0.0} : std::vector<double>{0.0,0.0,1.0};
    }

    for (int c_idx = 0; c_idx < num_labels; ++c_idx) {
        if (!tmp_positions[c_idx].empty()) {
            positions.push_back(tmp_positions[c_idx]);
            colors.push_back(tmp_colors[c_idx]);
        }
    }
    auto pipeline_end = std::chrono::steady_clock::now();
    RCLCPP_INFO(this->get_logger(), "[TIMER] Total pipeline took %ld ms",
                std::chrono::duration_cast<std::chrono::milliseconds>(pipeline_end - pipeline_start).count());


    publishMarkerArray(visualization_msgs::msg::Marker::CYLINDER, namespace_, fixed_frame, {positions, colors},
                       classified_cones_output_rviz_pub, true, {0.1,0.1,0.5}, msg->header.stamp);
}

void ProcessLidar::publishMarkerArray(
    visualization_msgs::msg::Marker::_type_type type,
    std::string ns,
    std::string frame_id,
    std::vector<std::vector<std::vector<double>>> positions_colours,
    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr publisher,
    bool del_markers,
    std::vector<double> scales,
    const rclcpp::Time& stamp)
{
    if (!publisher) return;
    visualization_msgs::msg::MarkerArray marker_array;

    if (del_markers) {
        visualization_msgs::msg::Marker del_marker; del_marker.action = visualization_msgs::msg::Marker::DELETEALL;
        marker_array.markers.push_back(del_marker);
    }

    visualization_msgs::msg::Marker marker;
    marker.header.frame_id = frame_id; marker.header.stamp = stamp; marker.ns = ns;
    marker.type = type; marker.action = visualization_msgs::msg::Marker::ADD; marker.pose.orientation.w = 1.0;
    marker.scale.x = scales.at(0); marker.scale.y = scales.at(1); marker.scale.z = scales.at(2);

    for (size_t i = 0; i < positions_colours[0].size(); ++i) {
        marker.id = i;
        marker.pose.position.x = positions_colours[0][i][0];
        marker.pose.position.y = positions_colours[0][i][1];
        marker.pose.position.z = positions_colours[0][i][2];
        marker.color.a = 1.0;
        marker.color.r = positions_colours[1][i][0];
        marker.color.g = positions_colours[1][i][1];
        marker.color.b = positions_colours[1][i][2];
        marker_array.markers.push_back(marker);
    }

    publisher->publish(marker_array);
}

bool ProcessLidar::classifyCone(const std::vector<double>& y_vals, const std::vector<double>& x_vals)
{
    if (y_vals.size() < 3) return false;
    int n = y_vals.size(); Eigen::MatrixXd A(n,3); Eigen::VectorXd y(n);
    for (int i=0;i<n;++i){ double x=x_vals[i]; A(i,0)=x*x; A(i,1)=x; A(i,2)=1.0; y(i)=y_vals[i]; }
    Eigen::Vector3d coeffs = A.colPivHouseholderQr().solve(y); return coeffs(0) > 0;
}

std::vector<double> ProcessLidar::movingAverage(const std::vector<double>& data, int kernel)
{
    int n=data.size(); std::vector<double> result(n,0.0); if(kernel<1) return data;
    int half = kernel/2; for(int i=0;i<n;++i){
        int start=std::max(0,i-half), end=std::min(n-1,i+half);
        double sum=0.0; for(int j=start;j<=end;++j) sum+=data[j]; result[i]=sum/(end-start+1);
    } return result;
}
