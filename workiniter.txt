/**
 * @file process_lidar.cpp
 * @brief Source (Definition / Implementation) file for the node
 * @author Siddhesh Phadke
 */

#include "perception_winter/process_lidar.hpp"
#include <string>
#include <algorithm>
#include <cmath>
#include <optional> // Required for iterative RANSAC
#include <open3d/Open3D.h>
#include <Eigen/Dense>
#include <pcl/point_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h> // Required for iterative RANSAC
#include <pcl/ModelCoefficients.h>      // Required for iterative RANSAC

ProcessLidar::ProcessLidar() : Node("process_lidar")
{
    // Shout out
    RCLCPP_INFO(this->get_logger(), "Process Lidar Node started");

    // Initializing
    this->lidar_raw_input_sub = this->create_subscription<sensor_msgs::msg::PointCloud>(
        this->lidar_raw_input_topic,
        10,
        std::bind(&ProcessLidar::lidar_raw_sub_callback, this, std::placeholders::_1)
    );

    // For final classified cones
    this->classified_cones_output_rviz_pub = this->create_publisher<visualization_msgs::msg::MarkerArray>(
        this->classified_cones_output_rviz_topic,
        10
    );

    // Initialize new RANSAC parameters
    this->min_z_normal_component = 0.90; // The minimum Z component for a normal to be considered horizontal
    this->max_slope_deviation_deg = 10.0; // Max angle difference between subsequent ground planes
}

// --- NEW: Definition for the destructor ---
ProcessLidar::~ProcessLidar()
{
    // Destructor
}

void ProcessLidar::lidar_raw_sub_callback(const sensor_msgs::msg::PointCloud::SharedPtr msg)
{
    RCLCPP_INFO(this->get_logger(), "[DEBUG] ---- lidar_raw_sub_callback entered ----");
    RCLCPP_INFO(this->get_logger(), "[DEBUG] Received point cloud with %zu points.", msg->points.size());

    // Publishing raw data and initialising position and intensity vectors
    std::vector<std::vector<double>> positions, colors;
    std::vector<double> intensities;

    // RANSAC
    RCLCPP_INFO(this->get_logger(), "[DEBUG] Starting iterative RANSAC ground segmentation...");

    // Convert sensor_msgs::PointCloud to pcl::PointCloud<pcl::PointXYZI>
    auto cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    cloud->points.reserve(msg->points.size());
    for (size_t i = 0; i < msg->points.size(); ++i) {
        const auto& pt = msg->points[i];
        
        // --- FIX: Add filter to remove points behind the car ---
        if (pt.x > 0) { // Only process points in front of the LiDAR
            const auto& intensity = msg->channels[0].values[i];
            pcl::PointXYZI p;
            p.x = pt.x;
            p.y = pt.y;
            p.z = pt.z;
            p.intensity = intensity;
            cloud->points.push_back(p);
        }
    }

    // This function now iteratively finds planes with constraints to avoid misclassifying cones.
    auto non_ground_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    auto ground_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
    auto remaining_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>(*cloud);
    
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::SACSegmentation<pcl::PointXYZI> seg;
    pcl::ExtractIndices<pcl::PointXYZI> extract;

    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setDistanceThreshold(this->ransac_threshold);

    int iterations = 0;
    const int max_iterations = 5;
    const size_t min_points_for_plane = 500; // Increased to avoid small clusters
    std::optional<Eigen::Vector3f> reference_normal;

    while (remaining_cloud->points.size() > min_points_for_plane && iterations < max_iterations)
    {
        seg.setInputCloud(remaining_cloud);
        seg.segment(*inliers, *coefficients);

        if (inliers->indices.empty()) {
            RCLCPP_INFO(this->get_logger(), "[HEARTBEAT] No more potential ground planes found.");
            break;
        }

        Eigen::Vector3f current_normal(coefficients->values[0], coefficients->values[1], coefficients->values[2]);
        if (current_normal.z() < 0) {
            current_normal = -current_normal;
        }

        if (current_normal.z() < this->min_z_normal_component) {
            RCLCPP_INFO(this->get_logger(), "[HEARTBEAT] Plane rejected: too vertical (normal Z=%.2f).", current_normal.z());
            break;
        }

        if (!reference_normal.has_value()) {
            reference_normal = current_normal;
            RCLCPP_INFO(this->get_logger(), "[HEARTBEAT] Acquired reference ground plane normal.");
        } else {
            double dot_product = current_normal.dot(reference_normal.value());
            double angle_rad = std::acos(std::clamp(dot_product, -1.0, 1.0));
            double angle_deg = angle_rad * (180.0 / M_PI);

            if (angle_deg > this->max_slope_deviation_deg) {
                RCLCPP_INFO(this->get_logger(), "[HEARTBEAT] Plane rejected: slope deviates by %.2f deg.", angle_deg);
                break;
            }
        }

        auto current_ground_plane = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
        extract.setInputCloud(remaining_cloud);
        extract.setIndices(inliers);
        extract.setNegative(false);
        extract.filter(*current_ground_plane);
        *ground_cloud += *current_ground_plane;

        extract.setNegative(true);
        auto next_remaining_cloud = std::make_shared<pcl::PointCloud<pcl::PointXYZI>>();
        extract.filter(*next_remaining_cloud);
        remaining_cloud = next_remaining_cloud;
        iterations++;
    }

    *non_ground_cloud = *remaining_cloud;

    // Populate positions and intensities from the final non_ground_cloud
    for (const auto& point : non_ground_cloud->points) {
        positions.push_back({point.x, point.y, point.z});
        intensities.push_back(point.intensity);
    }

    if (positions.empty()) {
        RCLCPP_INFO(this->get_logger(), "[DEBUG] No non-ground points to cluster. Exiting callback.");
        // --- FIX: Also clear old markers if no cones are found ---
        this->publishMarkerArray(
            visualization_msgs::msg::Marker::CYLINDER,
            this->namespace_,
            this->fixed_frame,
            {{}, {}}, // Empty positions and colors
            this->classified_cones_output_rviz_pub,
            true,
            {0.3, 0.3, 0.5},
            msg->header.stamp // Use original message time
        );
        return;
    }

    auto o3d_pcd = std::make_shared<open3d::geometry::PointCloud>();
    for (const auto& point : positions) {
        o3d_pcd->points_.emplace_back(
            static_cast<double>(point[0]),
            static_cast<double>(point[1]),
            static_cast<double>(point[2])
        );
    }

    std::vector<int> labels = o3d_pcd->ClusterDBSCAN(this->dbscan_epsilon, this->dbscan_minpoints);
    int num_labels = *std::max_element(labels.begin(), labels.end()) + 1;

    std::vector<std::vector<std::vector<double>>> classified_points(num_labels);

    for (size_t index = 0; index < positions.size(); index++) {
        int label = labels[index];
        if (label == -1) { continue; }
        auto point = positions.at(index);
        classified_points[label].push_back({point[0], point[1], point[2], intensities[index]});
    }

    for (auto& cone_class : classified_points) {
        std::sort(cone_class.begin(), cone_class.end(),
            [](const std::vector<double>& v1, const std::vector<double>& v2) -> bool {
                return v1[2] > v2[2];
            });
    }

    colors.clear();
    positions.clear();
    
    for (auto& class_ : classified_points) {
        int class_size = class_.size();
        if (class_size < 10) { continue; }
        
        std::vector<double> intensity_vals, z_vals;
        const double CONE_BASE_RADIUS = 0.12;
        
        auto min_x_it = std::min_element(class_.begin(), class_.end(), 
            [](const std::vector<double>& a, const std::vector<double>& b) {
                return a[0] < b[0];
            });
        
        // --- CHANGE START: Apply permanent offset to the final X-coordinate ---
        double cone_x = (*min_x_it)[0] + CONE_BASE_RADIUS + 2.921;
        double cone_y = (*min_x_it)[1];
        double cone_z = 0.025;
        
        for (auto& pt : class_) {
            intensity_vals.push_back(pt.at(3));
            z_vals.push_back(pt.at(2));
        }

        int kernel = std::max(3, static_cast<int>(0.1 * intensity_vals.size()));
        if (kernel % 2 == 0) kernel += 1;
        
        std::vector<double> averaged_intensity_vals = this->movingAverage(intensity_vals, kernel);
        positions.push_back({cone_x, cone_y, cone_z});
        
        if (this->classifyCone(averaged_intensity_vals, z_vals)) {
            colors.push_back({1.0, 1.0, 0.0});
        } else {
            colors.push_back({0.0, 0.0, 1.0});
        }
    }

    // Publishing classified cones
    this->publishMarkerArray(
        visualization_msgs::msg::Marker::CYLINDER,
        this->namespace_,
        this->fixed_frame,
        {positions, colors},
        this->classified_cones_output_rviz_pub,
        true,
        {0.1, 0.1, 0.5},
        msg->header.stamp // --- FIX: Use original message time
    );

    RCLCPP_INFO(this->get_logger(), "[DEBUG] ---- lidar_raw_sub_callback finished ----");
}

void ProcessLidar::publishMarkerArray(
    visualization_msgs::msg::Marker::_type_type type,
    std::string ns,
    std::string frame_id,
    std::vector<std::vector<std::vector<double>>> positions_colours,
    rclcpp::Publisher<visualization_msgs::msg::MarkerArray>::SharedPtr publisher,
    bool del_markers,
    std::vector<double> scales,
    const rclcpp::Time& stamp)
{
    RCLCPP_INFO(this->get_logger(), "[DEBUG] publishMarkerArray entered. Publishing %zu markers.", 
                positions_colours.at(0).size());

    visualization_msgs::msg::MarkerArray marker_array;
    
    if (del_markers) {
        visualization_msgs::msg::Marker del_marker;
        del_marker.action = visualization_msgs::msg::Marker::DELETEALL;
        marker_array.markers.push_back(del_marker);
    }

    visualization_msgs::msg::Marker marker;
    marker.header.frame_id = frame_id;
    marker.header.stamp = stamp;
    marker.ns = ns;
    marker.type = type;
    marker.action = visualization_msgs::msg::Marker::ADD;
    marker.pose.orientation.w = 1.0;
    marker.scale.x = scales.at(0);
    marker.scale.y = scales.at(1);
    marker.scale.z = scales.at(2);

    for (size_t i = 0; i < positions_colours.at(0).size(); i++) {
        marker.id = i;
        // --- CHANGE END: Removed the temporary visualization offset ---
        marker.pose.position.x = positions_colours.at(0).at(i).at(0);
        marker.pose.position.y = positions_colours.at(0).at(i).at(1);
        marker.pose.position.z = positions_colours.at(0).at(i).at(2);
        marker.color.a = 1.0;
        marker.color.r = positions_colours.at(1).at(i).at(0);
        marker.color.g = positions_colours.at(1).at(i).at(1);
        marker.color.b = positions_colours.at(1).at(i).at(2);
        marker_array.markers.push_back(marker);
    }

    publisher->publish(marker_array);
}

bool ProcessLidar::classifyCone(const std::vector<double> y_vals, std::vector<double> x_vals)
{
    if (y_vals.size() < 3) return false;

    int n = y_vals.size();
    Eigen::MatrixXd A(n, 3);
    Eigen::VectorXd y(n);

    for (int i = 0; i < n; ++i) {
        double x = x_vals.at(i);
        A(i, 0) = x * x;
        A(i, 1) = x;
        A(i, 2) = 1.0;
        y(i) = y_vals.at(i);
    }

    Eigen::Vector3d coeffs = A.colPivHouseholderQr().solve(y);

    return coeffs(0) > 0;
}

std::vector<double> ProcessLidar::movingAverage(const std::vector<double>& data, int kernel)
{
    int n = data.size();
    std::vector<double> result(n, 0.0);
    if (kernel < 1) return data;

    int half = kernel / 2;
    for (int i = 0; i < n; ++i) {
        int start = std::max(0, i - half);
        int end = std::min(n - 1, i + half);
        double sum = 0.0;
        for (int j = start; j <= end; ++j) {
            sum += data[j];
        }
        result[i] = sum / (end - start + 1);
    }
    return result;
}